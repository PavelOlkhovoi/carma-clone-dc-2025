name: Check PR
run-name: >
  ðŸ” : ${{ github.event.pull_request.title }}
on:
  pull_request:
    branches:
      - main

jobs:
  determine_projects:
    runs-on: ubuntu-latest
    outputs:
      project_list: ${{ steps.set_up_matrix.outputs.project_list }}
      e2e_list: ${{ steps.generate_e2e_list.outputs.e2e_list }}
      is_affected: ${{ steps.list_affected_projects.outputs.project_list != '' }}
      node-modules-cache-key: ${{ steps.node-cache-key.outputs.key }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: "recursive"
      - name: Update Submodules
        run: git submodule update --remote --recursive
      - name: Print Collaboration Version numbers
        run: |
          echo "-------------------------------"
          echo "All Collaboration Submodules:"
          echo
          find libraries -type f -name "package.json" -path "*/*-submodule/package.json" \
          -exec sh -c 'dir=$(dirname "$1"); echo "$(basename "$dir"): $(grep -m1 \"version\" "$1" | sed -E "s/[[:space:]]*\"version\":[[:space:]]*\"([^\"]+)\",/\\1/")"' _ {} \;

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"

      - name: add cismet-dev registry secret to .npmrc
        shell: bash
        run: |
          touch .npmrc
          echo "${{ secrets.CISMET_DEV_REGISTRY_SECRET_4_DOT_NPMRC }}" >> .npmrc

      - name: Generate node_modules cache key
        id: node-cache-key
        run: |
          echo "key=node-modules-${{ runner.os }}-node-20-${{ hashFiles('package-lock.json') }}" >> $GITHUB_OUTPUT

      - name: Restore node_modules from cache
        id: e2e-manual-node-cache
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ steps.node-cache-key.outputs.key }}

      - name: Install dependencies
        if: steps.e2e-manual-node-cache.outputs.cache-hit != 'true'
        run: npm install

      - name: Set Directory as Safe
        run: |
          git config --local --add safe.directory "$GITHUB_WORKSPACE"

      - name: Extract branch name
        shell: bash
        run: echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT
        id: extract_branch

      - name: Derive appropriate SHAs for base and head for `nx affected` commands
        id: setSHAs
        uses: nrwl/nx-set-shas@v4
        with:
          main-branch-name: ${{ github.event.pull_request.base.ref }}

      - run: |
          echo "BASE: ${{ steps.setSHAs.outputs.base }}"
          echo "HEAD: ${{ steps.setSHAs.outputs.head }}"

      - name: Load deployment configuration
        id: load_config
        run: |
          echo "load_config Projects in deployment" 
          config=$(cat deployment-config.json)
          project_keys=$(echo "$config" | jq -r '.projects | keys | map(@json) | @json')
          echo "project_keys=$project_keys" >> $GITHUB_ENV
          echo "Projects in deployment configuration: $project_keys"  # Debug output
          echo "::set-output name=deployment_projects::$project_keys"
      - name: Run nx command to show affected projects
        id: list_affected_projects
        run: |
          projects=$(npx nx show projects --affected -t build --base=${{ steps.setSHAs.outputs.base }} --head=${{ steps.setSHAs.outputs.head }})
          projects=$(echo $projects | tr '\n' ' ')
          echo "Affected projects: $projects"
          echo "::set-output name=project_list::$projects"

      - name: Set up matrix
        if: steps.list_affected_projects.outputs.project_list != ''
        id: set_up_matrix
        run: |
          # Convert the string into an array by splitting on spaces
          #IFS=' ' read -r -a project_array <<< "${{ steps.list_affected_projects.outputs.project_list }}"

          projects=$(echo "${{ steps.list_affected_projects.outputs.project_list }}")
          deployments=$(echo "${{ steps.load_config.outputs.deployment_projects }}"  | jq -r '.[]' | tr '\n' ' ')

          # Convert the string into arrays by splitting on spaces
          IFS=' ' read -r -a project_array <<< "$projects"
          IFS=' ' read -r -a deployment_array <<< "$deployments"

          # Declare an empty array to store the common elements
          result_array=()

          # Print the content of deployment_array for debugging
          # echo "Deployment String: $deployments"
          # echo "Deployment array content: ${deployment_array[@]}"
          #echo "project_array content: ${project_array[@]}"

          # Declare an empty array to store the common elements
          result_array=()

          # Iterate over each element in project_array
          for project in "${project_array[@]}"; do
              # Check if the project exists in deployment_array
              if [[ " ${deployment_array[@]} " =~ " ${project} " ]]; then
                  # If it exists, add it to the result_array
                  result_array+=("$project")
              fi
          done

          # Construct the JSON string manually
          result_json="["
          for ((i=0; i<${#result_array[@]}; i++)); do
              if [[ $i -ne 0 ]]; then
                  result_json="$result_json, "
              fi
              result_json="$result_json\"${result_array[i]}\""
          done
          result_json="$result_json]"

          # Print the result JSON
          # echo "$result_json"
          echo "::set-output name=project_list::$result_json"
          echo "PROJECT_LIST=${result_json}" >> $GITHUB_ENV

      - name: Generate E2E project list
        if: steps.list_affected_projects.outputs.project_list != ''
        id: generate_e2e_list
        run: |
          # Get the project list from the matrix setup
          projects='${{ steps.set_up_matrix.outputs.project_list }}'

          # Initialize empty array for E2E projects
          e2e_projects="[]"

          if [ "$projects" != "[]" ] && [ "$projects" != "" ]; then
            # Parse the JSON array and check each project for E2E existence
            e2e_list="["
            first=true
            
            # Extract project names from JSON array
            project_names=$(echo "$projects" | jq -r '.[]')
            
            for project in $project_names; do
              e2e_proj="e2e-$project"
              echo "Checking for E2E project: $e2e_proj"
              
              # Check if E2E project exists in nx workspace
              if npx nx show project "$e2e_proj" >/dev/null 2>&1; then
                echo "âœ… E2E project '$e2e_proj' found in nx workspace"
                
                # Check if smoke test folder exists and contains .spec.ts files
                smoke_files=$(find e2e -mindepth 2 -maxdepth 2 -name "$project" -type d -exec find {} -path "*/src/e2e/smoke/*.spec.ts" -type f \; 2>/dev/null | wc -l)
                
                if [ "$smoke_files" -gt 0 ]; then
                  echo "âœ… Found $smoke_files smoke test file(s) for $project"
                  if [ "$first" = true ]; then
                    e2e_list="$e2e_list\"$e2e_proj\""
                    first=false
                  else
                    e2e_list="$e2e_list, \"$e2e_proj\""
                  fi
                else
                  echo "âŒ No smoke test files found in smoke/ folder for project '$project'"
                fi
              else
                echo "âŒ E2E project '$e2e_proj' not found in nx workspace"
              fi
            done
            
            e2e_list="$e2e_list]"
            e2e_projects="$e2e_list"
          fi

          echo "::set-output name=e2e_list::$e2e_projects"
          echo "E2E_LIST=$e2e_projects" >> $GITHUB_ENV

      - name: Show project list
        run: |
          echo "The project list is |${{ steps.set_up_matrix.outputs.project_list }}|"
          echo "Is affected: ${{ steps.list_affected_projects.outputs.project_list != '' }}"

  build:
    needs: determine_projects
    runs-on: ubuntu-latest
    if: ${{ needs.determine_projects.outputs.is_affected == 'true' && needs.determine_projects.outputs.project_list != '[]' }}
    strategy:
      matrix:
        project: ${{ fromJson(needs.determine_projects.outputs.project_list) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: "recursive"
      - name: Update Submodules
        run: git submodule update --remote --recursive
      - name: Print Collaboration Version numbers
        run: |
          echo "-------------------------------"
          echo "All Collaboration Submodules:"
          echo
          find libraries -type f -name "package.json" -path "*/*-submodule/package.json" \
          -exec sh -c 'dir=$(dirname "$1"); echo "$(basename "$dir"): $(grep -m1 \"version\" "$1" | sed -E "s/[[:space:]]*\"version\":[[:space:]]*\"([^\"]+)\",/\\1/")"' _ {} \;

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"

      - name: add cismet-dev registry secret to .npmrc
        shell: bash
        run: |
          touch .npmrc
          echo "${{ secrets.CISMET_DEV_REGISTRY_SECRET_4_DOT_NPMRC }}" >> .npmrc

      - name: Generate node_modules cache key
        id: node-cache-key
        run: |
          echo "key=node-modules-${{ runner.os }}-node-20-${{ hashFiles('package-lock.json') }}" >> $GITHUB_OUTPUT

      - name: Restore node_modules from cache
        id: e2e-manual-node-cache
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ steps.node-cache-key.outputs.key }}

      - name: Install dependencies
        if: steps.e2e-manual-node-cache.outputs.cache-hit != 'true'
        run: npm install

      - name: Build project
        run: |
          ${{ env.ADDITIONAL_ENVS }} npx nx run ${{ matrix.project }}:build --configuration=production --base="${{ env.BASE_URL }}" --output-style=stream-without-prefixes
        shell: bash

  smokeTestPr:
    needs: [determine_projects]
    runs-on: ubuntu-latest
    if: ${{ needs.determine_projects.outputs.is_affected == 'true' && needs.determine_projects.outputs.e2e_list != '[]' }}
    permissions:
      actions: write
      contents: read
    strategy:
      fail-fast: true
      matrix:
        project: ${{ fromJson(needs.determine_projects.outputs.e2e_list) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: "recursive"

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"

      - name: add cismet-dev registry secret to .npmrc
        shell: bash
        run: |
          touch .npmrc
          echo "${{ secrets.CISMET_DEV_REGISTRY_SECRET_4_DOT_NPMRC }}" >> .npmrc

      - name: Restore node_modules from cache
        id: smoke-test-node-cache
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ needs.determine_projects.outputs.node-modules-cache-key }}

      - name: Install dependencies
        if: steps.smoke-test-node-cache.outputs.cache-hit != 'true'
        run: npm install

      - name: Run E2E tests for project
        run: |
          echo "Running E2E tests for project: ${{ matrix.project }}"
          echo "This corresponds to the E2E test job for ${{ matrix.project }}"

      - name: Run E2E tests
        run: PW_CHANNEL=chrome npx nx e2e ${{ matrix.project }} --grep="smoke/" --skip-nx-cache --skipInstall

      - name: Report the smoke test failure
        if: failure()
        run: |
          {
            echo "## âŒ Smoke Test Failed for \`${{ matrix.project }}\`"
            echo ""
            echo "### ðŸ” Run locally via command"
            echo ""
            echo '```bash'
            echo "npx nx e2e ${{ matrix.project }} --grep=smoke/ --skip-nx-cache --skipInstall"
            echo '```'
            echo ""
            echo "### âš¡ Re-run only the last failed"
            echo ""
            echo '```bash'
            echo "npx nx e2e ${{ matrix.project }} --grep=smoke/ --skip-nx-cache --skipInstall --last-failed"
            echo '```'
          } >> $GITHUB_STEP_SUMMARY

      - name: Cancel workflow on smoke test failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const run_id = process.env.GITHUB_RUN_ID;
            await github.rest.actions.cancelWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id,
            });
            core.info(`Requested cancellation of workflow run ${run_id} due to smoke test failure.`)
